/** @file
 * @brief base class for asynchronous thrift client
 * @author yafei.zhang@langtaojin.com
 * @date
 * @version
 *
 */
#ifndef ASYNC_CLIENT_H
#define ASYNC_CLIENT_H

#include <async_connection.h>
#include <async_processor.h>
#include <list>

namespace apache { namespace thrift { namespace async {

  /*
   * AsyncThriftClient(using TFramedTransport, TBinaryProtocol)
   *
   * socket layer asynchronous
   * RPC asynchronous
   */
  class AsyncThriftClient : public AsyncConnection
  {
    public:
      typedef ::apache::thrift::async::AsyncRPCCallback AsyncRPCCallback;

    protected:
      typedef AsyncConnection BaseType;
      struct AsyncOp
      {
        //If 'callback' is invoked with an 'erroneous' code,
        //the connection at client side shall be connected.
        //If 'callback' is invoked with a 'successful' code,
        //the connection at client side may be reused.
        AsyncRPCCallback callback;
        int rpc_type;
        //pointer to various return value. if it is 0, the return type is "void"
        void * _return;
        bool is_oneway;
      };

      boost::shared_ptr<AsyncOp> pending_async_op_;
      void complete_pending_op(const boost::system::error_code& ec);

    public:
      AsyncThriftClient();
      explicit AsyncThriftClient(const boost::shared_ptr<boost::asio::ip::tcp::socket>& socket);
      virtual ~AsyncThriftClient();

      //NOTICE:
      //If there are pending asynchronous operations, attach and detach may throw.
      //attach shall close the previous inner 'socket_' and release the previous inner 'strand_'.
      void attach(const boost::shared_ptr<boost::asio::ip::tcp::socket>& socket);
      void detach();

    protected:
      virtual void on_close(const boost::system::error_code& ec);
      virtual void on_handle_read(const boost::system::error_code& ec, size_t bytes_transferred);
      virtual void on_handle_write(const boost::system::error_code& ec, size_t bytes_transferred);
      virtual void on_handle_frame();

      //NOTICE:
      //overrided by codes that generated by thrift compiler.
      //this function fill the field of 'AsyncOp::_return'.
      virtual void fill_result(AsyncOp& op) = 0;//may throw
  };

} } } // namespace

#endif
