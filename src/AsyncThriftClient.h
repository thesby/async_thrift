/** @file
* @brief base class for asynchronous thrift client
* @author yafei.zhang@langtaojin.com
* @date
* @version
*
*/
#ifndef ASYNC_THRIFT_CLIENT_H
#define ASYNC_THRIFT_CLIENT_H

#include <list>
#include <AsyncConnection.h>

namespace apache { namespace thrift { namespace async {

  /*
  * AsyncThriftClient(using TFramedTransport, TBinaryProtocol)
  *
  * socket layer asynchronous
  * RPC asynchronous
  */
  class AsyncThriftClient : public AsyncConnection
  {
  public:
    typedef ::apache::thrift::async::AsyncRPCCallback AsyncRPCCallback;

  protected:
    struct AsyncOp
    {
      //If 'callback' is invoked with an 'erroneous' code,
      //the connection at client side shall be sconnected.
      //If 'callback' is invoked with a 'successful' code,
      //the connection at client side may be reused.
      AsyncRPCCallback callback;
      int rpc_type;
      //pointer to various return value. if it is 0, the return type is "void"
      void * _return;
      bool is_oneway;
    };

    std::list<boost::shared_ptr<AsyncOp> > async_op_list_;
    boost::shared_ptr<AsyncOp> pending_async_op_;

  public:
    AsyncThriftClient();
    explicit AsyncThriftClient(const boost::shared_ptr<boost::asio::ip::tcp::socket>& socket);
    virtual ~AsyncThriftClient();

  protected:
    virtual void on_close(const boost::system::error_code * ec);
    virtual void on_attach(const boost::shared_ptr<boost::asio::ip::tcp::socket>& socket);
    virtual void on_detach();
    virtual void on_handle_read(const boost::system::error_code& ec, size_t bytes_transferred);
    virtual void on_handle_write(const boost::system::error_code& ec, size_t bytes_transferred);
    virtual void on_handle_frame();

    //NOTICE:
    //overrided by codes that generated by thrift compiler.
    //this function fill the field of 'AsyncOp::_return'.
    virtual void fill_result(AsyncOp& op) = 0;//may throw
  };

} } } // namespace

#endif
